Sun 02 Aug 2020 07:41:52 PM +05

Общая проблема: необходимо учесть параметр продвижения (propagation) для точек
монтирования в Linux. Важно, как минимум, уметь устанавливать им режим private.
В текущем коде chroot-tool параметры продвижения учитываются, как обычные опции
монтирования, и это нормально работало, продвижение устанавливалось нормально и
не менялось при необходимых операциях с chroot.

Положение изменилось с началом использования systemd. Systemd по некоторым
причинам (пока не понятным), меняет продвижения точек монтирования, они
перестают соответствовать указанным в настройках для chroot. Это приводит к
попытке ремонтирования (unmount; mount) точки монтирования, и, как следствие, к
ошибкам, потому что это происходит и при включенных chroot, с запущенными в них
процессах (то есть, операции ремонтирования пользователи не ожидают).

Ситуацию можно исправить. Нормальный способ установки опций продвижения для
точек монтирования -- это при помощи --make параметров утилиты mount:

  mount --make-private /xyz

Эту операцию можно выполнять без ремонтирования точки. Решение многогранное.

Решение.

1. Нужно некоторым образом различать параметры продвижения.

  Эти параметры выбраны так, что их можно смешивать с прочими параметрами mount.
  Там нет пересечений, поэтому выделить параметры продвижения из общего списка
  параметров точки монтирования в gen-bindings и filter-bindings не сложно. Не
  сложно извлечь их и из переменной PROPAGATION, возвращаемой findmnt.

2. В filter-bindings нужно разделить проверки точки монтирования, опций
монтирования и параметров продвижения.

  Кое-какая подготовительная работа для этого сделана, поэтому не сложно. Здесь
  нужно будет усложить структуру mount-reсords, и, наверное, привести к
  нормальному виду понятие о множестве опций. Добавить процедуры для работы с
  множествами.

3. Самое сложное: нужно научить chroot-tool.sh разбираться в том, что следует
делать. Желательно так, чтобы код на Bash не пришлось делать шибко умным. В Bash
с этим тяжело.

  Можно поступить так: разбить в filter-bindings весь список работ для
  chroot-tool.sh на 3 группы:

    3.1. Полное монтирования (потому что точки нет в списке).

    3.2. Ремонтирование (потому что неверные параметры монтирования). Это уже
    есть, обозначено флагом R в списке работ.

    3.3. Изменение параметров продвижения. Можно propagate. Такую
    запись можно упихать в стандартную 4-ёх элементную запись о задании:

      propagate
      флаги для make: --make-private, --make-slave, ... etc
      source: не используется
      target

  В filter-bindings много логики разбиения общего плана работ на части, поэтому
  общий план можно упорядочить так:

    3.4. монтирование;
    3.5. ремонтирование по каким-то причинам;
    3.6. установка параметров продвижения.
  
  В chroot-tool.sh каждая операция монтирования независима, поэтому chroot-tool
  об этой структуре может и не знать.

Выглядит, как план работ. Можно начинать

Tue 04 Aug 2020 12:01:39 AM +05

С опциями в Mount-Record какой-то бардак. Зачем-то они постоянно перегоняются из
списков в строки, из строк в списки или таблицы. Это бессмысленное усложнение
логики. Что фактически-то нужно?

Фактически нужны просто наборы опций и возможность понять, содержится ли один
набор в другом наборе. Для этого теперь есть абстракция kit и предикаты: kit<=?,
kit-contains?. Поэтому хорошо бы все опции безусловно хранить в kit-ах.

Кроме этого, Mount-Record теперь должна теперь содержать не только опции
монтирования, но и опции продвижения (propagation). Логика для их сравнения
такая же, как и для простых опций. Поэтому, их бы тоже неплохо хранить в виде
kit-ов.

Проблема в том, что kit<=? kit превращает в список элементов, а потом проверяет
их при помощи kit-contains. Ну, и не понятно, как сделать лучше.

  РЕШЕНИЕ: Поэтому, видимо, имеет смысл, то, что уже смонтировано хранить в виде
  kit (потому что уже опции уже смонтированного должны содержать те опции,
  которые мы бы хотели установить), а ожидаемые опции хранить в виде списка.
  Тогда логика будет максимально простой. kit-contains? автоматически учтёт
  повторения, с этим проблем не будет.

Проблема в том, что mount-record теперь должна содержать 5 полей, вместе с
propagation, а весь код оперирует 4-параметрическим конструктором. И это
нормально, потому что это сделано в стиле /etc/fstab, в котором опции
продвижения записаны вместе с другими опциями монтирования. И эти опции надо
выделить.

  РЕШЕНИЕ: Сделать конструктор-обёртку над mount-record, который по словарю
  будет разбивать опции на опции продвижения и опции монтирования. Список опций
  продвижения известен.

Fri 07 Aug 2020 12:05:08 AM +05

Хорошо. Сейчас всё упирается в процедурку dump-mnt. Она должна выводить 4
строки. Но всякий раз эти 4 строки должны быть разными. Видимо, нужны какие-то
флажки для этого. Константами, наверное, это можно сделать:

  DUMP-OPTIONS
  DUMP-PROPAGATIONS
  DUMP-BOTH

Fri 07 Aug 2020 06:16:48 PM +05

Хорошо, надо уметь отметить все причины ремонтирования. Но теперь не просто так,
чтобы порадовать пользователя сообщениями, а потому что надо составить план
монтирования по этим причинам.

Ну, а что остаётся? Надо просто отметить списком маркеров, каждый маркер - это
пара из причины и строки с описанием причины.

Tue Aug 25 09:53:21 AM +05 2020

Необходимо выделить из chroot-tool библиотеку для повторного использования в
других проектах. В основном речь идёт о функциях работы с файлами и
директориями. В chroot-tool существуют и специальные модули. Например, модуль,
работающий с точками монтирования. Такие модули в общей библиотеке не нужны.
Поэтому директорию lact надо разделить на пару директорий.

Самый простой вариант:

  lib - собственные модули chroot-tool
  lact - общие модули для разных проектов

Однако, при этом возникает проблема загрузки. Потому что используемые в исходном
коде директивы загрузки модулей, например

  (import (lact utils))

опираются на структуру файловой системы. Это не гибко и не очень хорошо. Внутри
lib не должно быть никаких проблем, потому что это местная библиотека,
установленная по фиксированному пути. Внутри lact (библиотеки, вынесенной в
отдельный git-модуль) это может быть проблемой, потому что заранее не известно,
по какому пути это всё содержимое будет загружено. Другая проблема: изнутри lact
для тестирования и других потребностей тоже необходимо уметь загружать эти
модули.

Как вариант решение проблемы, попробовать создать символическую ссылку на
текущую директорию.

  lact/lact → lact

Tue Aug 25 11:55:13 AM +05 2020

В принципе работает. Единственная проблема: осмысленными становятся пути вида

  chroot-tool/lact/lact/lact/lact/lact/lact/lact

Но наши процедуры и системный readlink могут с таким справится. Попробуем
